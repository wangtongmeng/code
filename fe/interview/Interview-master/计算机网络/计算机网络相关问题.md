<details>
  <summary>1、常见的http请求</summary>
  常见的HTTP请求方法包括以下几种：

1. GET：
   GET 方法用于从服务器获取资源，通过 URL 传递参数，一般用于获取数据。GET 请求的特点是幂等性，多次请求同一个 URL 返回的结果应该是相同的，不会对服务器产生副作用。

2. POST：
   POST 方法用于向服务器提交数据，一般用于创建新资源或提交表单数据。POST 请求将数据放在请求的消息体中发送给服务器，相比 GET 方法，POST 请求可以传递更多的数据，并且不会对服务器产生幂等性要求。

3. PUT：
   PUT 方法用于向服务器更新资源，一般用于更新已有资源。PUT 请求需要提供完整的资源表示，即将整个资源替换为请求中提供的新数据。

4. DELETE：
   DELETE 方法用于删除服务器上的资源。DELETE 请求删除指定 URL 对应的资源。

5. PATCH：
   PATCH 方法用于对服务器上的资源进行部分更新，一般用于更新资源的某些属性。PATCH 请求只需要提供需要修改的部分数据，而不需要提供完整的资源表示。

6. HEAD：
   HEAD 方法与 GET 方法类似，但服务器在响应中只返回头部信息，不返回实际的响应体。HEAD 请求常用于获取资源的元数据，如检查资源是否存在、获取资源的大小等。

7. OPTIONS：
   OPTIONS 方法用于获取服务器支持的 HTTP 方法列表，以及服务器的配置信息。客户端可以使用 OPTIONS 方法向服务器发起预检请求，以确定服务器是否允许发送实际的请求。

除了这些常见的 HTTP 请求方法，还有一些不太常用但有特定用途的方法，如 TRACE（用于追踪请求在代理服务器上的传输路径）和 CONNECT（用于与代理服务器建立隧道连接）等。

</details>

<details>
  <summary>2、get请求和post请求的区别</summary>

1. 数据传递方式：

   - GET 请求：GET 请求通过 URL 的查询参数（query parameters）传递数据，将数据附加在 URL 的末尾，以`?`开始，键值对之间使用`&`连接。例如：`http://example.com/api?param1=value1&param2=value2`。GET 请求的数据会被包含在 URL 中，可见于 URL 的历史记录、浏览器地址栏等。
   - POST 请求：POST 请求通过请求的消息体（request body）传递数据，数据不会直接暴露在 URL 中。数据通常以表单形式或 JSON 等格式进行编码，并通过请求头中的`Content-Type`字段指定编码方式。

2. 数据传输大小：

   - GET 请求：由于 GET 请求的数据附加在 URL 中，URL 的长度有限制，不同浏览器对 URL 长度的支持有所不同，通常限制在几千个字符。因此，GET 请求适合传输少量数据。
   - POST 请求：POST 请求将数据放在请求的消息体中，没有对数据大小做出明确限制，可以传输较大的数据量。

3. 安全性：

   - GET 请求：GET 请求的数据通过 URL 传递，数据会被包含在 URL 中，因此在网络传输过程中可能被截获，对于包含敏感信息的请求不太安全。此外，GET 请求的数据会出现在 URL 的各种记录中，包括浏览器历史记录、服务器日志等。
   - POST 请求：POST 请求的数据在请求的消息体中传递，不会直接暴露在 URL 中，相对于 GET 请求更安全一些，适合传输包含敏感信息的数据。

4. 幂等性：
   - GET 请求：GET 请求具有幂等性，多次请求同一个 URL 返回的结果应该是相同的，不会对服务器产生副作用。GET 请求不应该对服务器进行数据修改、状态变更等操作。
   - POST 请求：POST 请求不具备幂等性，多次发送相同的 POST 请求可能会导致服务器上的资源被重复创建或修改。POST 请求常用于创建、更新资源等对服务器状态产生影响的操作。

综上所述，GET 请求适合获取数据、查询操作，对数据大小和安全性要求较低；POST 请求适合提交数据、创建、更新资源等操作，对数据大小和安全性有较高要求。在实际应用中，根据具体的需求和场景选择适当的请求方法。

</details>

<details>
  <summary>3、常见的http请求头</summary>

以下是一些常见的 HTTP 请求头部字段：

1. Accept：
   指定客户端能够处理的媒体类型，用于告知服务器客户端接受的内容类型。例如：

   ```
   Accept: text/html, application/json

   ```

2. Content-Type：
   指定请求消息体的媒体类型，用于告知服务器请求的内容类型。例如：

   ```
   Content-Type: application/json

   ```

3. User-Agent：
   指定发起请求的用户代理（浏览器、应用程序等）的信息，用于告知服务器请求的来源。例如：

   ```
   User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36

   ```

4. Authorization：
   指定身份验证凭证，用于在请求中发送认证信息。常用于基本身份验证（Basic Authentication）或令牌身份验证（Token Authentication）。例如：

   ```
   Authorization: Bearer <token>

   ```

5. Cookie：
   指定之前服务器发送的 Cookie 值，用于在请求中携带会话信息。例如：

   ```
   Cookie: sessionId=abc123; userId=987654

   ```

6. Referer：
   指定请求的源 URL，用于告知服务器请求的来源页面。例如：

   ```
   Referer: http://example.com/page1.html

   ```

7. Accept-Language：
   指定客户端偏好的语言，用于告知服务器客户端接受的语言类型。例如：

   ```
   Accept-Language: en-US,en;q=0.9

   ```

8. If-None-Match：
   指定之前响应中的实体标识（ETag），用于条件请求，仅当该标识与服务器上的资源匹配时，才返回实际的响应。例如：

   ```
   If-None-Match: "abc123"

   ```

9. Content-Length：
   指定请求消息体的长度，用于告知服务器请求消息体的大小。例如：

   ```
   Content-Length: 1234

   ```

10. Host：
    指定请求的目标主机，用于告知服务器请求的目标地址。例如：
    ```
    Host: example.com
    ```

以上是一些常见的请求头部字段，实际应用中可能会根据需求和场景添加或修改其他头部字段。HTTP 协议规范定义了更多的请求头部字段，开发人员可以根据需要选择适合的字段来实现特定的功能和需求。

</details>

<details>
  <summary>4、常见的http响应头</summary>

以下是一些常见的 HTTP 响应头部字段：

1. Content-Type：
   指定响应消息体的媒体类型，用于告知客户端响应的内容类型。例如：

   ````
   Content-Type: application/json
   ```

   ````

2. Content-Length：
   指定响应消息体的长度，用于告知客户端响应消息体的大小。例如：

   ```
   Content-Length: 1234
   ```

3. Cache-Control：
   指定缓存机制的行为，用于告知客户端如何处理响应的缓存。例如：

   ```
   Cache-Control: max-age=3600, public
   ```

4. Last-Modified：
   指定实体的最后修改时间，用于告知客户端资源的最后更新时间。例如：

   ```
   Last-Modified: Mon, 02 Sep 2023 10:00:00 GMT
   ```

5. ETag：
   指定实体的唯一标识，用于校验资源的完整性和一致性。例如：

   ```
   ETag: "abc123"
   ```

6. Location：
   指定重定向的目标 URL，用于告知客户端请求的重定向位置。例如：

   ````
   Location: http://example.com/newpage
   ```

   ````

7. Set-Cookie：
   设置 HTTP Cookie，用于在响应中向客户端设置一个或多个 Cookie 值。例如：

   ````
   Set-Cookie: sessionId=abc123; Expires=Wed, 08 Sep 2023 10:00:00 GMT; Path=/
   ```

   ````

8. Access-Control-Allow-Origin：
   指定允许访问资源的跨域请求的来源，用于支持跨域资源共享（CORS）。例如：

   ````
   Access-Control-Allow-Origin: http://example.com
   ```

   ````

9. Server：
   指定响应的服务器软件名称和版本号，用于告知客户端响应的服务器信息。例如：

   ````
   Server: Apache/2.4.7 (Ubuntu)
   ```

   ````

10. Date：
    指定响应生成的日期和时间，用于告知客户端响应的创建时间。例如：
    ```
    Date: Wed, 08 Sep 2023 10:00:00 GMT
    ```

以上是一些常见的响应头部字段，实际应用中可能会根据需求和场景添加或修改其他头部字段。HTTP 协议规范定义了更多的响应头部字段，开发人员可以根据需要选择适合的字段来实现特定的功能和需求。

</details>

<details>
  <summary>5、常见的http状态码</summary>

HTTP 状态码是用于表示客户端和服务器之间通信过程中发生的结果的三位数字代码。以下是一些常见的 HTTP 状态码及其含义的示例：

1. 200 OK：
   表示请求成功。服务器成功处理了请求并返回了所需的内容。

2. 301 Moved Permanently：
   表示请求的资源已永久移动到了新的 URL。客户端应该使用`新的 URL`进行后续的请求。

3. 302 临时重定向
   当服务器收到客户端的请求后，如果需要将请求重定向到另一个 URL，但该重定向只是临时的，客户端应该继续使用`原始URL`进行后续请求。
   当客户端收到 HTTP 302 状态码时，会自动向服务器发送一个新的请求，请求的目标 URL 是从响应的 Location 头部字段中获取的。服务器在发送 302 响应时，通常会在 Location 字段中提供重定向的目标 URL。

4. 400 Bad Request：
   表示请求存在语法错误或无法被服务器理解。

5. 404 Not Found：
   表示请求的资源未找到。服务器无法找到请求的资源。

6. 500 Internal Server Error：
   表示服务器内部发生了错误，导致无法完成请求。

7. 302 Found：
   表示请求的资源临时移动到了新的 URL。客户端应该继续使用原始的 URL 进行后续的请求。

8. 304 Not Modified：
   该状态码表示客户端发送的条件请求（通常是使用 If-Modified-Since 或 If-None-Match 头）的结果，指示请求的资源未发生变化，可以直接使用客户端缓存的副本。服务器返回 304 Not Modified 时，响应中不包含响应体，而是通过响应头中的一些字段（例如 ETag、Last-Modified）提供缓存验证信息。

9. 401 Unauthorized：
   表示请求需要进行身份验证。客户端需要提供有效的身份验证凭证才能访问请求的资源。

10. 403 Forbidden：
    表示服务器拒绝了请求。客户端没有访问请求资源的权限。

11. 503 Service Unavailable：
    表示服务器当前无法处理请求。通常是由于服务器过载或维护导致的。

12. 204 No Content：
    表示服务器成功处理了请求，但没有返回任何内容。

</details>

<details>
  <summary>6、强缓存和协商缓存以及和304的关系</summary>
  见同文件夹中强缓存和协商缓存文件
</details>

<details>
  <summary>7、https和http的区别</summary>

- HTTPS 协议需要 CA 证书，费用较高；而 HTTP 协议不需要；
- HTTP 协议是超文本传输协议，信息是明文传输的，HTTPS 则是具有安全性的 SSL 加密传输协议；
- 使用不同的连接方式，端口也不同，HTTP 协议端口是 80，HTTPS 协议端口是 443；
- HTTP 协议连接很简单，是无状态的;HTTPS 协议是有 SSL 和 HTTP 协议构建的可进行加密传输、身份认证的
  网络协议，比 HTTP 更加安全。

HTTP/2 是相对于 HTTP/1.1 的升级版本，它在性能、效率和功能方面进行了显著改进。以下是 HTTP/2 和 HTTP/1 的一些主要区别：

1. 多路复用：
   HTTP/2 引入了多路复用的机制，允许在同一个 TCP 连接上同时发送多个请求和响应，而无需按照顺序进行。这样可以避免 HTTP/1 中的队头阻塞问题，提高了并发性能。

2. 二进制分帧：
   HTTP/2 使用二进制分帧的方式对数据进行传输和解析，将请求和响应拆分为多个小的二进制帧（frames），并对其进行标识和优先级管理。这种方式比 HTTP/1 中的文本格式更高效，并且可以更好地适应网络传输的特性。

3. 头部压缩：
   HTTP/2 使用 HPACK 压缩算法对请求和响应的头部进行压缩。头部压缩减少了数据传输的大小，降低了带宽消耗，并且减少了网络延迟。

4. 服务器推送：
   HTTP/2 支持服务器主动推送资源给客户端，即在客户端发出请求后，服务器可以主动推送其他相关资源给客户端，避免了客户端重复请求的需求，提高了页面加载的速度和效率。

5. 优先级和依赖：
   HTTP/2 允许在请求和响应之间建立依赖关系，并为每个请求设置优先级。这样可以确保重要资源的优先加载，提高用户体验。

6. 首部字段复用：
   HTTP/2 使用首部字段表（header table）来存储和复用相同的首部字段，避免了重复传输相同的信息，减少了数据传输量。

总体而言，HTTP/2 相对于 HTTP/1.1 提供了更高的性能、更好的效率和更丰富的功能。它引入了多路复用、二进制分帧、头部压缩等特性，通过减少延迟、提高并发性能和减少带宽消耗，改善了 Web 应用的性能和用户体验。

</details>

<details>
  <summary>8、http1和http1.1和http2</summary>
HTTP/1.1是相对于HTTP/1.0的升级版本，它在性能、功能和持久连接等方面进行了改进。以下是HTTP/1和HTTP/1.1的一些主要区别：

1. 持久连接：
   HTTP/1.0 默认使用短连接，即每个请求和响应后都会关闭连接。而 HTTP/1.1 引入了持久连接，允许在单个 TCP 连接上发送多个请求和响应，从而减少了连接建立的开销，提高了性能。

2. 流水线化：
   HTTP/1.1 支持请求的流水线化，即在一个 TCP 连接上可以同时发送多个请求，而无需等待每个请求的响应。这样可以减少延迟，提高并发性能。

3. 身份验证：
   HTTP/1.1 提供了更多的身份验证机制，如基本认证、摘要认证等，增强了对资源访问的安全性。

4. 缓存控制：
   HTTP/1.1 引入了更灵活的缓存机制，通过 Cache-Control、ETag、If-None-Match 等头部字段来控制缓存的行为，提高了缓存的效果。

5. 错误处理：
   HTTP/1.1 引入了更具体的错误状态码，例如 413 Request Entity Too Large（请求实体过大）和 416 Requested Range Not Satisfiable（请求范围无法满足），使得错误处理更加明确和精确。

6. Host 头部字段：
   HTTP/1.1 要求请求头部中必须包含 Host 字段，以区分多个虚拟主机的请求。这样可以在同一个服务器上托管多个网站，并正确路由请求。

7. 支持更多的请求方法：
   HTTP/1.1 引入了更多的请求方法，例如 OPTIONS、DELETE、TRACE 等，扩展了 HTTP 的功能和用途。

总体而言，HTTP/1.1 相对于 HTTP/1.0 提供了更高的性能、更好的安全性和更丰富的功能。它引入了持久连接、流水线化、缓存控制等特性，使得 HTTP 协议更加适应现代 Web 应用的需求。

HTTP/2 是相对于 HTTP/1.1 的升级版本，它在性能、效率和功能方面进行了显著改进。以下是 HTTP/2 和 HTTP/1 的一些主要区别：

1. 多路复用：
   HTTP/2 引入了多路复用的机制，允许在同一个 TCP 连接上同时发送多个请求和响应，而无需按照顺序进行。这样可以避免 HTTP/1 中的队头阻塞问题，提高了并发性能。

2. 二进制分帧：
   HTTP/2 使用二进制分帧的方式对数据进行传输和解析，将请求和响应拆分为多个小的二进制帧（frames），并对其进行标识和优先级管理。这种方式比 HTTP/1 中的文本格式更高效，并且可以更好地适应网络传输的特性。

3. 头部压缩：
   HTTP/2 使用 HPACK 压缩算法对请求和响应的头部进行压缩。头部压缩减少了数据传输的大小，降低了带宽消耗，并且减少了网络延迟。

4. 服务器推送：
   HTTP/2 支持服务器主动推送资源给客户端，即在客户端发出请求后，服务器可以主动推送其他相关资源给客户端，避免了客户端重复请求的需求，提高了页面加载的速度和效率。

5. 优先级和依赖：
   HTTP/2 允许在请求和响应之间建立依赖关系，并为每个请求设置优先级。这样可以确保重要资源的优先加载，提高用户体验。

6. 首部字段复用：
   HTTP/2 使用首部字段表（header table）来存储和复用相同的首部字段，避免了重复传输相同的信息，减少了数据传输量。

总体而言，HTTP/2 相对于 HTTP/1.1 提供了更高的性能、更好的效率和更丰富的功能。它引入了多路复用、二进制分帧、头部压缩等特性，通过减少延迟、提高并发性能和减少带宽消耗，改善了 Web 应用的性能和用户体验。

</details>

<details>
  <summary>9、HTTP/2的多路复用机制是如何解决队头阻塞问题的</summary>

HTTP 队头阻塞

HTTP1.1 允许在持久连接上可选的使用请求管道
管道允许客户端在已发送请求后就发送下一个请求，不需要等待前一个请求响应，借此来减少等待时间；
但是客户端要求服务端按照请求发送的顺序返回响应，原因很简单：HTTP请求和响应并没有序列号标识，无法将乱序的响应与请求关联起来；
也就意味着如果一个响应返回延迟了，那么后续的响应都会延迟；这就造成了 HTTP队头阻塞；

HTTP/2的多路复用机制是通过在单个TCP连接上同时发送多个请求和响应来解决队头阻塞问题的。下面是多路复用如何工作的简要说明：

1. 帧（Frames）和流（Streams）：
   在 HTTP/2 中，请求和响应被拆分为更小的二进制帧（frames）进行传输。这些帧按照顺序发送，但不需要按照顺序接收和处理。每个帧都被分配一个唯一的标识符，称为流（stream）。

2. 并发的流：
   在单个 TCP 连接上，可以同时存在多个流。每个流都可以承载一个独立的请求和响应。这意味着多个请求和响应可以同时进行，无需按照顺序等待前一个请求的响应。

3. 优先级：
   HTTP/2 允许为每个流设置优先级。通过设置优先级，可以告诉服务器哪些请求更重要，应该优先处理。服务器可以根据优先级来决定数据的传输顺序，确保重要的请求优先得到响应。

4. 头部压缩：
   HTTP/2 使用 HPACK 压缩算法对请求和响应的头部进行压缩。头部压缩减少了数据传输的大小，降低了带宽消耗，并且减少了网络延迟。

通过多路复用机制，HTTP/2 允许在一个 TCP 连接上同时发送多个请求和响应，避免了 HTTP/1 中的队头阻塞问题。这样可以提高并发性能和吞吐量，并显著减少页面加载时间和延迟。同时，通过优先级设置和头部压缩等机制，HTTP/2 进一步优化了性能和效率。

</details>

<details>
   <summary>10、cookie有哪些属性</summary>

Cookie 是一种在客户端（浏览器）和服务器之间传递的小型数据片段，用于跟踪和存储用户的状态信息。一个 Cookie 可以包含以下属性：

1. Name（名称）：Cookie 的名称，用于标识特定的 Cookie。名称是区分大小写的，必须是唯一的。

2. Value（值）：Cookie 的值，存储在 Cookie 中的数据内容。

3. Domain（域）：指定 Cookie 适用的域名。浏览器会根据域名匹配规则来确定哪些请求会带上该 Cookie。默认情况下，Cookie 只适用于设置它的域名。

4. Path（路径）：指定 Cookie 适用的路径。只有当请求的路径与 Cookie 的路径匹配时，浏览器才会发送 Cookie。默认情况下，Cookie 的路径是设置 Cookie 的页面路径。

5. Expires（过期时间）：指定 Cookie 的过期时间。一旦过期，浏览器会自动删除该 Cookie。如果没有设置过期时间，Cookie 会在浏览器会话结束时被删除。

6. Max-Age（最大存活时间）：指定 Cookie 的最大存活时间，以秒为单位。与 Expires 属性不同，Max-Age 是相对时间，指定了从 Cookie 被创建之时开始计算的存活时间。

7. Secure（安全标志）：指定是否只在安全连接（HTTPS）下才发送该 Cookie。如果设置了 Secure 属性且当前连接不是安全连接，浏览器不会发送该 Cookie。

8. HttpOnly（只能通过 HTTP 访问）：指定是否限制 Cookie 只能通过 HTTP 请求发送，而不能通过客户端脚本（如 JavaScript）访问。这可以增加对跨站点脚本攻击（XSS）的防护。

这些属性为 Cookie 提供了更多的控制和灵活性，使得开发者可以根据需要设置 Cookie 的作用域、有效期和安全性等。需要注意的是，某些属性可能只在特定的浏览器中受支持或有特定的行为，因此在使用 Cookie 时应该参考相关的文档和规范。

</details>

<details>
   <summary>11、如何跨域携带cookies</summary>

服务端需要设置

```
Access-Control-Allow-Credentials: true
Access-Control-Allow-Origin: [特定域名] // 不可以是*
```

客户端
XMLHttpRequest 发请求需要设置 withCredentials=true，fetch 发请求需要设置 credentials = include

</details>

<details>
  <summary>12、浏览器从url输入到渲染完成的过程</summary>
浏览器从URL输入到页面渲染完成的过程可以分为以下几个主要步骤：

1. URL 解析和 DNS 查询：
   当用户在浏览器中输入 URL 时，浏览器会解析 URL，提取出协议（如 HTTP、HTTPS）、主机名（如www.example.com）和路径等信息。然后，浏览器会进行DNS查询，将主机名解析为对应的IP地址。

2. 建立 TCP 连接：
   浏览器使用解析得到的 IP 地址，与服务器建立 TCP 连接。这涉及到三次握手过程，即客户端发送 SYN 包，服务器返回 SYN-ACK 包，最后客户端发送 ACK 包进行确认。

3. 发起 HTTP 请求：
   一旦 TCP 连接建立，浏览器会发送 HTTP 请求到服务器。HTTP 请求包含请求方法（例如 GET、POST）、路径、请求头部等信息。

4. 服务器处理请求和响应：
   服务器接收到浏览器发送的 HTTP 请求后，会根据请求的内容进行处理。这可能涉及到服务器端的业务逻辑、数据库查询、文件读取等操作。服务器处理完请求后，会生成 HTTP 响应并发送回浏览器。

5. 接收响应并解析：
   浏览器接收到 HTTP 响应后，会解析响应内容。首先，浏览器会检查响应的状态码，例如 200 表示成功，404 表示页面未找到等。然后，浏览器解析响应的头部信息，包括响应的内容类型、缓存策略等。接着，浏览器开始逐步解析响应的主体内容。

6. 构建 DOM 树：
   浏览器解析 HTML 响应内容，构建 DOM（文档对象模型）树。DOM 树表示 HTML 文档的结构，包括 HTML 标签、元素、文本内容等。

7. 样式计算和生成渲染树：
   浏览器解析 CSS 样式表，并将样式应用于 DOM 树中的元素，计算每个元素的样式。然后，浏览器将 DOM 树和样式计算结果组合成渲染树（Render Tree）。

8. 布局（Layout）：
   浏览器根据渲染树的结构和样式计算结果，确定每个元素在屏幕上的位置和大小。这个过程被称为布局或重排。

9. 绘制（Painting）：
   浏览器使用绘图引擎将布局后的元素绘制到屏幕上，创建用户可见的图像。这个过程被称为绘制或重绘。

10. 加载和执行脚本：
    如果 HTML 文档中包含 JavaScript 代码，浏览器会下载并执行这些脚本。脚本的执行可能会修改 DOM 树、样式、发送额外的请求等。

11. 加载和渲染外部资源：
    在解析和渲染过程中，浏览器可能会遇到外部资源，例如 CSS 文件、图像、字体文件等。浏览器会并行下载这些资源，并根据需要进行渲染。

12. 页面加载完成：
    当所有必要的资源都下载完成、DOM 树构建完毕、样式计算、布局、绘制等过程完成后，页面加载完成。此时，用户可以与页面进行交互。

需要注意的是，以上过程是一个简化的描述，实际页面加载过程中可能会有一些优化和并行处理。不同浏览器和网络环境也可能会对页面加载过程产生一些差异。

</details>

<details>
  <summary>13、UDP和TCP的区别和使用场景</summary>

见这篇文章的 UDP 和 TCP 部分
https://www.yuque.com/cuggz/interview/cdpgm0#vNWJY

</details>

<details>
  <summary>14、WebSocket</summary>

见这篇文章的 WebSocket 部分
https://www.yuque.com/cuggz/interview/cdpgm0#vNWJY

</details>

<details>
  <summary>15、XSS和CSRF</summary>

XSS（跨站脚本攻击）和 CSRF（跨站请求伪造）是前端开发中两个常见的网络安全威胁，它们可以对网站和用户造成严重的风险。

XSS 攻击：
XSS 攻击指的是攻击者将恶意脚本注入到网页中，然后在用户浏览器中执行这些恶意脚本。攻击者通常通过在输入验证或过滤不足的情况下插入恶意脚本来实现攻击。当用户访问被注入恶意脚本的网页时，脚本会在用户的浏览器中执行，攻击者可以利用这些脚本来窃取用户的敏感信息、劫持用户会话、修改网页内容等。

预防 XSS 攻击的方法包括：

1. 对用户输入进行严格的验证和过滤，确保不信任的数据不会被执行或展示。
2. 在输出到网页之前对用户输入进行转义，以防止脚本被执行。
3. 使用内容安全策略（Content Security Policy，CSP）来限制页面中可以加载的资源和脚本。
4. 使用 XSS 过滤器或安全框架来检测和阻止潜在的 XSS 攻击。

CSRF 攻击：
CSRF 攻击是指攻击者利用用户在其他网站上已经通过身份验证的会话，欺骗用户执行恶意操作。攻击者构造一个伪造的请求，使用户在目标网站上执行该请求，从而以用户的身份发送未经授权的操作。这种攻击利用了用户身份验证的可信性，而不是直接攻击目标网站的漏洞。

预防 CSRF 攻击的方法包括：

1. 使用 CSRF 令牌（CSRF Token）：在每个表单或敏感操作中包含一个随机生成的令牌，该令牌与用户会话相关联。服务器在接收到请求时验证该令牌的有效性，如果令牌无效，则拒绝请求。
2. 检查 Referer 头：服务器可以检查请求中的 Referer 头，确保请求来自预期的来源。但需要注意，Referer 头并不总是可靠的。
3. 实施双重身份验证（Two-Factor Authentication，2FA）：引入双重身份验证可以增加用户账户的安全性，降低 CSRF 攻击的风险。

综上所述，XSS 和 CSRF 攻击都是前端开发中需要重视的安全威胁。通过采取适当的安全措施和最佳实践，可以减少这些攻击的风险，并确保网站和用户的安全。

</details>

<details>
  <summary>16、http3</summary>

HTTP/3（或称为 HTTP over QUIC）是下一代的 HTTP 协议，它基于 QUIC（Quick UDP Internet Connections）传输协议。QUIC 是一种基于用户数据报协议（UDP）的传输协议，旨在提供更快的连接建立和数据传输速度，以及更好的网络拥塞控制和错误恢复机制。

HTTP/3 相对于 HTTP/2 和 HTTP/1.1 有以下主要特点：

1. 基于 QUIC：HTTP/3 使用 QUIC 作为底层传输协议，而不是 TCP。QUIC 可以提供更快的连接建立时间，减少了握手的延迟，并通过多路复用技术，在单个连接上同时传输多个请求和响应，从而提高了效率。

2. 低延迟：HTTP/3 通过减少握手延迟、使用 0-RTT（零往返时间）技术和更快的拥塞控制算法，可以降低请求的延迟。这对于实时应用程序和对低延迟要求较高的场景非常有益。

3. 可靠性：QUIC 协议内置了错误恢复机制，可以更快地检测和恢复数据传输中的错误，从而提供更可靠的连接。相比于 TCP+TLS 的组合，QUIC 可以更好地应对网络切换和移动网络环境中的连接中断。

4. 更好的性能：HTTP/3 通过多路复用、头部压缩和流量控制等技术，可以更高效地利用网络带宽，并减少额外的网络延迟。这有助于提高网页加载速度和用户体验。

需要注意的是，HTTP/3 仍然处于发展阶段，尚未被广泛部署和支持。不同于 HTTP/1.1 和 HTTP/2，HTTP/3 的使用需要服务器和客户端都支持 QUIC 协议。因此，在实际应用中，需要考虑到服务端和客户端的支持情况，并进行适当的配置和兼容性处理，才能使用 HTTP/3 来获得其带来的好处。

</details>

<details>
  <summary>1、常见的http请求</summary>

</details>

<details>
  <summary>1、常见的http请求</summary>

</details>
