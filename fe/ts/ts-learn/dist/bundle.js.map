{"version":3,"file":"bundle.js","sources":["../src/base-type.ts"],"sourcesContent":["// 基础类型\n// string number boolean 数组 元组 枚举 null undefined void never any object symbol bigInt\n\n// 基础类型 小写\nlet a: number = 1\nlet b: string = 'str'\nlet c: boolean = true\n\n// 包装类型 首字母大写，大写用来描述实例类型\nlet a1: Number = new Number(1)\nlet b2: String = new String('str')\nlet b3: String = 'str' // 在赋值时，子级可赋值给父级\n\n\n// 数组\n// 声明数组的两种方式：类型[] 或 Array<类型>\n// 数组要求的是存储的格式按照特定类型来存储，不关心位置\nlet arr1: number[] = [1,2,3]\nlet arr2: Array<number> = [1,2,3]\nlet arr3: (number | string)[] = [1,2,'3'] // 通过联合类型实现，数组项多类型\n\n// 元组 tuple\n// 关心固定位置类型的数组，元组新增内容时，不能增加额外类型的值，只能是已有的，而且增加后无法访问\nlet tuple: [number, string] = [1, '2']\n// tuple.push(true) // 报错\ntuple.push(1)\n// tuple[2] // 报错\n\n// 枚举：自带类型的对象\n// 维护一组常量时使用\n// 枚举没有值时会根据上面的索引自动累加\n// 类型可以反举（值是数字时，可以反过来枚举）\n// 异构枚举，枚举中不止有数字还有字符串，如果上一个是字符串，则下一个无法推导\n// 常量枚举，不会额外编译成对象，更节约\n// enum STATUS {\n//   'OK',\n//   'NOT_OK'\n// }\n// console.log(STATUS.OK); // 0\n// console.log(STATUS[0]); // 反举 'OK'\n// 异构枚举\n// enum STATUS1 {\n//   'OK' = 'OK',\n//   'NOT_OK' // 报错，需要初始化值，无法自动推导\n// }\n// 常量枚举\nconst enum STATUS2 {\n  'OK',\n  'NOT_OK'\n}\nconsole.log(STATUS2.OK); // console.log(0 /* STATUS2.OK */);\n\n// null undefined 基本类型\nlet u: undefined = undefined\nlet n: null = null\n// 非严格模式在关闭时，null可以赋值给undefined(在tsconfig.json中，\"strictNullChecks\": false,)\n// 如果禁用非严格null检测，null和undefined 可以赋值给任何类型（null,undefined是任何类型的子类型）\nu = null\nn = undefined\nlet s: string = null\n\n// void 空类型 一般表示函数的返回值\nfunction func1():void {\n  // undefined 可以赋予给 void，都代表空（undefined 是 void 的子类型）\n  return undefined\n}\n\n\n// never 永远到达不了的地方\n// 函数无法执行完毕\nfunction whileTrue():never {\n  while(true) {}\n}\n// 报错时\nfunction throwError():never{\n  throw Error()\n}\n// 如果 if/else 条件都走完了，没有遗漏的，后面的类型就是never（完整性保护）\n// 111 => [1,1,1]\n// '111' => ['1', '1', '1']\n// true => ['t', 'r', 'u', 'e']\nfunction validateCheck(v:never) {}\nfunction toArray(val: number | string | boolean){\n  if (typeof val === 'number') {\n    return val.toString().split('').map(Number)\n  }\n  if (typeof val === 'string') {\n    return val.split('')\n  }\n  if (typeof val === 'boolean') {\n    return val.toString().split('').map(Number)\n  }\n  // never类型，只能被never类型赋值\n  validateCheck(val) // 代码的完整性保护（注释掉前面的某个判断，会报错）\n}\n\n\n// any 任何类型，都不写就不写，会导致类型丧失检测\nlet any1: any = 1\nany1 = '1'\n\n// object 引用类型\nfunction create (val: object) {\n\n}\ncreate({})\ncreate(function(){})\ncreate([])\n\n// symbol bigInt\nconst symbol: symbol = Symbol()\nconst bigint:bigint = BigInt(Number.MAX_SAFE_INTEGER) // 配置 tsconfig.json  lib: [\"ESNext\", \"DOM\"] \"DOM\"是为了解决console.log报错\n\n\n"],"names":[],"mappings":";;;EAkDA,OAAO,CAAC,GAAG,CAAY,CAAA,kBAAA,CAAC;EA6DF,MAAM,CAAC,MAAM,CAAC,gBAAgB,EAAC;;;;;;"}