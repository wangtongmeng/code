{"version":3,"file":"bundle.js","sources":["../src/base-type.ts"],"sourcesContent":["// 基础类型 小写\nlet a: number = 1\nlet b: string = 'str'\nlet c: boolean = true\n\n// 包装类型 首字母大写，大写用来描述实例类型\nlet a1: Number = new Number(1)\nlet b2: String = new String('str')\nlet b3: String = 'str' // 在赋值时，子级可赋值给父级\n\n\n// 数组\n// 声明数组的两种方式：类型[] 或 Array<类型>\n// 数组要求的是存储的格式按照特定类型来存储，不关心位置\nlet arr1: number[] = [1,2,3]\nlet arr2: Array<number> = [1,2,3]\nlet arr3: (number | string)[] = [1,2,'3'] // 通过联合类型实现，数组项多类型\n\n// 元组 tuple\n// 关心固定位置类型的数组，元组新增内容时，不能增加额外类型的值，只能是已有的，而且增加后无法访问\nlet tuple: [number, string] = [1, '2']\n// tuple.push(true) // 报错\ntuple.push(1)\n// tuple[2] // 报错\n\n// 枚举：自带类型的对象\n// 维护一组常量时使用\n// 枚举没有值时会根据上面的索引自动累加\n// 类型可以反举（值是数字时，可以反过来枚举）\n// 异构枚举，枚举中不止有数字还有字符串，如果上一个是字符串，则下一个无法推导\n// 常量枚举，不会额外编译成对象，更节约\n// enum STATUS {\n//   'OK',\n//   'NOT_OK'\n// }\n// console.log(STATUS.OK); // 0\n// console.log(STATUS[0]); // 反举 'OK'\n// 异构枚举\n// enum STATUS1 {\n//   'OK' = 'OK',\n//   'NOT_OK' // 报错，需要初始化值，无法自动推导\n// }\n// 常量枚举\nconst enum STATUS2 {\n  'OK',\n  'NOT_OK'\n}\nconsole.log(STATUS2.OK); // console.log(0 /* STATUS2.OK */);\n\n// null undefined 基本类型\nlet u: undefined = undefined\nlet n: null = null\n// 非严格模式在关闭时，null可以赋值给undefined(在tsconfig.json中，\"strictNullChecks\": false,)\n// 如果禁用非严格null检测，null和undefined 可以赋值给任何类型（null,undefined是任何类型的子类型）\nu = null\nn = undefined\nlet s: string = null\n\n\n\n"],"names":[],"mappings":";;;EA+CA,OAAO,CAAC,GAAG,CAAY,CAAA,kBAAA,CAAC;;;;;;"}